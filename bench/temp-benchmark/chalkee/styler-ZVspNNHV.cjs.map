{"version":3,"file":"styler-ZVspNNHV.cjs","sources":["../src/ansi.ts","../src/styler.ts"],"sourcesContent":["/**\n * ANSI escape code definitions and utilities\n */\n\n// Export the core ANSI codes object for direct access\n// Core ANSI codes are now handled by the core-colors plugin\nexport const ansiCodes = {} as const\n\nexport interface AnsiCodes {\n  open: string\n  close: string\n}\n\nexport type StyleName = keyof typeof ansiCodes\n\n/**\n * Check if colors should be enabled based on environment\n */\nexport function isColorSupported(): boolean {\n  // NO_COLOR environment variable disables colors\n  if (process.env.NO_COLOR) {\n    return false\n  }\n\n  // Check for common CI environments\n  if (process.env.CI && !process.env.COLORTERM) {\n    return false\n  }\n\n  // If FORCE_COLOR is set, enable colors\n  if (process.env.FORCE_COLOR) {\n    return true\n  }\n\n  // Check if running in a TTY\n  if (typeof process !== 'undefined' && process.stdout && !process.stdout.isTTY) {\n    return false\n  }\n\n  return true\n}\n\n// Color utility functions are now handled by the color-utilities plugin","import {\n  type AnsiCodes,\n  isColorSupported,\n} from './ansi'\nimport type { StyledFunction } from './types'\nimport {\n  handleProperty,\n  processText,\n  filterMarkerCodes,\n  registeredCodes\n} from './registry'\n\n// Proxy cache to reuse proxy objects for the same code combinations\n// Use a more efficient cache key generation\nconst proxyCache = new Map<string, StyledFunction>()\n\n/**\n * Generate an efficient cache key\n * Instead of JSON.stringify, we use a simpler approach\n */\nfunction generateCacheKey(codes: AnsiCodes[], accumulatedText: string): string {\n  // For empty codes, just use accumulated text\n  if (codes.length === 0) {\n    return `text:${accumulatedText}`\n  }\n  \n  // For codes, create a simple string representation\n  const codesKey = codes.map(c => `${c.open}|${c.close}`).join(',')\n  return `${codesKey}|${accumulatedText}`\n}\n\n/**\n * Apply ANSI codes to text\n */\nfunction applyStyle(text: string, codes: AnsiCodes[]): string {\n  if (!isColorSupported() || codes.length === 0) {\n    return text\n  }\n\n  const openCodes = codes.map((c) => c.open).join('')\n  const closeCodes = codes\n    .map((c) => c.close)\n    .reverse()\n    .join('')\n\n  return `${openCodes}${text}${closeCodes}`\n}\n\n/**\n * Create a styled function with chaining support\n * @param codes - Array of ANSI codes to apply\n * @param accumulatedText - Text accumulated from previous calls (for chaining after function calls)\n */\nexport function createStyler(codes: AnsiCodes[] = [], accumulatedText: string = ''): StyledFunction {\n  // Create a more efficient cache key\n  const cacheKey = generateCacheKey(codes, accumulatedText)\n\n  // Check if we have a cached proxy for this combination\n  if (proxyCache.has(cacheKey)) {\n    return proxyCache.get(cacheKey)!\n  }\n\n  // Define the custom inspect symbol\n  const inspectCustom = Symbol.for('nodejs.util.inspect.custom')\n\n  // Main function that handles both regular calls and template literals\n  const stylerFunction = function (\n    this: unknown,\n    ...args: [string] | [TemplateStringsArray, ...unknown[]]\n  ): StyledFunction {\n    // Handle template literal call\n    if (Array.isArray(args[0]) && 'raw' in args[0]) {\n      const strings = args[0] as TemplateStringsArray\n      const values = args.slice(1)\n      const text = strings.reduce(\n        (result, str, i) => result + str + (values[i] !== undefined ? String(values[i]) : ''),\n        ''\n      )\n\n      // Let plugins handle special mode behaviors\n      const pluginResult = processText(codes, text, accumulatedText)\n      let styledText = ''\n\n      if (pluginResult) {\n        styledText = pluginResult.styledText\n      } else {\n        // Fallback to default behavior - apply styles to the text (excluding markers)\n        styledText = applyStyle(text, filterMarkerCodes(codes))\n      }\n\n      // Return a new styler with accumulated text\n      return createStyler(codes, accumulatedText + styledText)\n    }\n\n    // Handle regular function call\n    const text = String(args[0] ?? '')\n\n    // Let plugins handle special mode behaviors\n    const pluginResult = processText(codes, text, accumulatedText)\n    let styledText = ''\n\n    if (pluginResult) {\n      styledText = pluginResult.styledText\n    } else {\n      // Fallback to default behavior - apply styles to the text (excluding markers)\n      styledText = applyStyle(text, filterMarkerCodes(codes))\n    }\n\n    // Return a new styler with accumulated text\n    return createStyler(codes, accumulatedText + styledText)\n  }\n\n  // Override toString and valueOf to return accumulated text\n  stylerFunction.toString = () => accumulatedText\n  stylerFunction.valueOf = () => accumulatedText\n\n  // Add Symbol.toPrimitive for proper string conversion\n  Object.defineProperty(stylerFunction, Symbol.toPrimitive, {\n    value: (hint: string) => {\n      if (hint === 'string' || hint === 'default') {\n        return accumulatedText\n      }\n      return accumulatedText\n    },\n    enumerable: false,\n  })\n\n  // Custom inspect is defined on the proxy\n\n  // Add toStringTag for better object representation\n  Object.defineProperty(stylerFunction, Symbol.toStringTag, {\n    value: 'Crayon',\n    enumerable: false,\n  })\n\n  // For the root styler, add common properties directly for better performance\n  if (accumulatedText === '' && codes.length === 0) {\n    // Add common color properties for root styler\n    Object.defineProperties(stylerFunction, {\n      red: {\n        get() {\n          return createStyler([registeredCodes.red], '')\n        },\n        enumerable: true,\n        configurable: true\n      },\n      blue: {\n        get() {\n          return createStyler([registeredCodes.blue], '')\n        },\n        enumerable: true,\n        configurable: true\n      },\n      green: {\n        get() {\n          return createStyler([registeredCodes.green], '')\n        },\n        enumerable: true,\n        configurable: true\n      },\n      bold: {\n        get() {\n          return createStyler([registeredCodes.bold], '')\n        },\n        enumerable: true,\n        configurable: true\n      },\n      underline: {\n        get() {\n          return createStyler([registeredCodes.underline], '')\n        },\n        enumerable: true,\n        configurable: true\n      }\n    })\n  }\n\n  // Create proxy to intercept property access for chaining\n  const proxy = new Proxy(stylerFunction, {\n    get: (target, prop: string | symbol) => {\n      if (typeof prop === 'symbol') {\n        // @ts-expect-error - Accessing symbol properties on function\n        return target[prop as any]\n      }\n\n      // Special properties for string conversion\n      if (prop === 'toString' || prop === 'valueOf') {\n        return target[prop]\n      }\n\n      // Handle Symbol.toPrimitive\n      if (typeof prop === 'symbol' && prop === Symbol.toPrimitive) {\n        return target[prop]\n      }\n\n      // Handle util.inspect.custom\n      const inspectCustom = Symbol.for('nodejs.util.inspect.custom')\n      if (typeof prop === 'symbol' && prop === inspectCustom) {\n        return () => accumulatedText\n      }\n\n      // Prepare options for plugins\n      const pluginOptions = {\n        createStyler,\n        ansiCodes: registeredCodes,\n      }\n\n      // Let plugins handle property access\n      const pluginResult = handleProperty(\n        stylerFunction as unknown as StyledFunction,\n        prop as string,\n        codes,\n        accumulatedText,\n        pluginOptions\n      )\n      if (pluginResult !== undefined) {\n        return pluginResult\n      }\n\n      // Check if it's a standard style in our combined ansiCodes\n      if (prop in registeredCodes) {\n        return createStyler([...codes, registeredCodes[prop as keyof typeof registeredCodes]], accumulatedText)\n      }\n\n      return undefined\n    },\n  })\n\n  // Add custom inspect method directly to the proxy\n  Object.defineProperty(proxy, inspectCustom, {\n    value: () => accumulatedText,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  })\n\n  // Cache the proxy for reuse\n  const styledFunction = proxy as unknown as StyledFunction\n  proxyCache.set(cacheKey, styledFunction)\n\n  return styledFunction\n}"],"names":["text","pluginResult","processText","styledText","filterMarkerCodes","registeredCodes","inspectCustom","handleProperty"],"mappings":"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"}