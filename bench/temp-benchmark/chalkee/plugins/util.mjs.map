{"version":3,"file":"util.mjs","sources":["../../src/plugins/util.ts"],"sourcesContent":["/**\r\n * Color utilities plugin\r\n * Provides hex, rgb, bgHex, bgRgb color utilities with proper TypeScript augmentation\r\n */\r\nimport type { StylePlugin } from './base'\r\nimport type { AnsiCodes } from '../ansi'\r\nimport type { StyledFunction } from '../types'\r\nimport { register, plugins } from '../registry'\r\n\r\n/**\r\n * Create RGB foreground ANSI code\r\n */\r\nexport function createRgbCode(r: number, g: number, b: number): AnsiCodes {\r\n  return {\r\n    open: `\\x1b[38;2;${r};${g};${b}m`,\r\n    close: '\\x1b[39m',\r\n  }\r\n}\r\n\r\n/**\r\n * Create RGB background ANSI code\r\n */\r\nexport function createBgRgbCode(r: number, g: number, b: number): AnsiCodes {\r\n  return {\r\n    open: `\\x1b[48;2;${r};${g};${b}m`,\r\n    close: '\\x1b[49m',\r\n  }\r\n}\r\n\r\n/**\r\n * Parse hex color string to RGB values\r\n */\r\nexport function parseHex(hex: string): [number, number, number] {\r\n  // Remove # if present\r\n  hex = hex.replace(/^#/, '')\r\n\r\n  // Expand shorthand (e.g., \"03F\" to \"0033FF\")\r\n  if (hex.length === 3) {\r\n    hex = hex\r\n      .split('')\r\n      .map((char) => char + char)\r\n      .join('')\r\n  }\r\n\r\n  if (hex.length !== 6) {\r\n    throw new Error(`Invalid hex color: ${hex}`)\r\n  }\r\n\r\n  const r = parseInt(hex.slice(0, 2), 16)\r\n  const g = parseInt(hex.slice(2, 4), 16)\r\n  const b = parseInt(hex.slice(4, 6), 16)\r\n\r\n  if (isNaN(r) || isNaN(g) || isNaN(b)) {\r\n    throw new Error(`Invalid hex color: ${hex}`)\r\n  }\r\n\r\n  return [r, g, b]\r\n}\r\n\r\n/**\r\n * Validate RGB values\r\n */\r\nexport function validateRgb(r: number, g: number, b: number): void {\r\n  if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {\r\n    throw new Error(`RGB values must be between 0 and 255. Got: ${r}, ${g}, ${b}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Convert HSL to RGB\r\n * @param h Hue (0-360)\r\n * @param s Saturation (0-100)\r\n * @param l Lightness (0-100)\r\n */\r\nexport function hslToRgb(h: number, s: number, l: number): [number, number, number] {\r\n  h = h % 360\r\n  if (h < 0) h += 360\r\n  s = Math.max(0, Math.min(100, s))\r\n  l = Math.max(0, Math.min(100, l))\r\n\r\n  const c = (1 - Math.abs(2 * l / 100 - 1)) * s / 100\r\n  const x = c * (1 - Math.abs((h / 60) % 2 - 1))\r\n  const m = l / 100 - c / 2\r\n\r\n  let r = 0, g = 0, b = 0\r\n  if (h < 60) {\r\n    r = c; g = x; b = 0\r\n  } else if (h < 120) {\r\n    r = x; g = c; b = 0\r\n  } else if (h < 180) {\r\n    r = 0; g = c; b = x\r\n  } else if (h < 240) {\r\n    r = 0; g = x; b = c\r\n  } else if (h < 300) {\r\n    r = x; g = 0; b = c\r\n  } else {\r\n    r = c; g = 0; b = x\r\n  }\r\n\r\n  return [\r\n    Math.round((r + m) * 255),\r\n    Math.round((g + m) * 255),\r\n    Math.round((b + m) * 255)\r\n  ]\r\n}\r\n\r\nexport const utilPlugin: StylePlugin = {\r\n  name: 'util',\r\n\r\n  /**\r\n   * Handle property access for color utilities\r\n   * Return undefined to let the core system handle it through ansiCodes\r\n   */\r\n  handleProperty(_target: StyledFunction, prop: string, codes: AnsiCodes[], accumulatedText: string, options?: { createStyler?: Function, ansiCodes?: Record<string, AnsiCodes>, pluginRegistry?: any }): StyledFunction | undefined {\r\n    // Use the passed createStyler function to avoid circular dependencies\r\n    if (!options?.createStyler) {\r\n      return undefined\r\n    }\r\n\r\n    // Handle hex color utility\r\n    if (prop === 'hex' || prop === 'h') {\r\n      const handler = (color: string) => {\r\n        const [r, g, b] = parseHex(color)\r\n        // Check if we're in background-color mode\r\n        const bgModeMarker = getBgModeCodeMarker()\r\n        const bgMode = bgModeMarker ? codes.some(code => code.open === bgModeMarker) : false\r\n        // In bg-mode, use background RGB code\r\n        const rgbCode = bgMode ? createBgRgbCode(r, g, b) : createRgbCode(r, g, b)\r\n        return (options.createStyler as Function)([...codes, rgbCode], accumulatedText)\r\n      }\r\n      return handler as unknown as StyledFunction\r\n    }\r\n\r\n    // Handle bgHex color utility (explicit background, ignores bg-mode)\r\n    if (prop === 'bgHex') {\r\n      const handler = (color: string) => {\r\n        const [r, g, b] = parseHex(color)\r\n        const rgbCode = createBgRgbCode(r, g, b)\r\n        return (options.createStyler as Function)([...codes, rgbCode], accumulatedText)\r\n      }\r\n      return handler as unknown as StyledFunction\r\n    }\r\n\r\n    // Handle rgb color utility\r\n    if (prop === 'rgb') {\r\n      const handler = (r: number, g: number, b: number) => {\r\n        validateRgb(r, g, b)\r\n        // Check if we're in background-color mode\r\n        const bgModeMarker = getBgModeCodeMarker()\r\n        const bgMode = bgModeMarker ? codes.some(code => code.open === bgModeMarker) : false\r\n        // In bg-mode, use background RGB code\r\n        const rgbCode = bgMode ? createBgRgbCode(r, g, b) : createRgbCode(r, g, b)\r\n        return (options.createStyler as Function)([...codes, rgbCode], accumulatedText)\r\n      }\r\n      return handler as unknown as StyledFunction\r\n    }\r\n\r\n    // Handle bgRgb color utility (explicit background, ignores bg-mode)\r\n    if (prop === 'bgRgb') {\r\n      const handler = (r: number, g: number, b: number) => {\r\n        validateRgb(r, g, b)\r\n        const rgbCode = createBgRgbCode(r, g, b)\r\n        return (options.createStyler as Function)([...codes, rgbCode], accumulatedText)\r\n      }\r\n      return handler as unknown as StyledFunction\r\n    }\r\n\r\n    return undefined\r\n  }\r\n}\r\n\r\n// Self-register the plugin when imported\r\nregister(utilPlugin)\r\n\r\n// Augment the StyledFunction interface with color utility properties\r\n// This provides IntelliSense for the color utilities\r\ndeclare module '../types' {\r\n  interface StyledFunction {\r\n    // Color utilities\r\n    hex: (color: string) => StyledFunction\r\n    h: (color: string) => StyledFunction\r\n    bgHex: (color: string) => StyledFunction\r\n    rgb: (r: number, g: number, b: number) => StyledFunction\r\n    bgRgb: (r: number, g: number, b: number) => StyledFunction\r\n  }\r\n}\r\n\r\n// Function to dynamically get BG_MODE_CODE_MARKER from bg plugin\r\nfunction getBgModeCodeMarker(): string | undefined {\r\n  // Find the bg plugin in the plugins array\r\n  const bgPlugin = plugins.find(plugin => plugin.name === 'bg')\r\n\r\n  // If the bg plugin is found and has the marker, return it\r\n  if (bgPlugin && (bgPlugin as any).BG_MODE_CODE_MARKER) {\r\n    return (bgPlugin as any).BG_MODE_CODE_MARKER\r\n  }\r\n\r\n  return undefined\r\n}\r\n"],"names":[],"mappings":"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"}