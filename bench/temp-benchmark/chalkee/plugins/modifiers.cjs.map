{"version":3,"file":"modifiers.cjs","sources":["../../src/plugins/modifiers.ts"],"sourcesContent":["/**\r\n * Modifiers plugin\r\n * Provides ANSI modifier codes (bold, italic, underline, etc.) with proper TypeScript augmentation\r\n */\r\nimport type { StylePlugin } from './base'\r\nimport type { AnsiCodes } from '../ansi'\r\nimport type { StyledFunction } from '../types'\r\nimport { register, registerCodes, plugins } from '../registry'\r\n\r\n// Handle reset operation - clear special mode markers and add reset code\r\nfunction handleReset(codes: AnsiCodes[], resetCode: AnsiCodes): AnsiCodes[] {\r\n    // Quick exit if no plugins have isMarkerCode method\r\n    let hasIsMarkerCode = false\r\n    for (let i = 0; i < plugins.length; i++) {\r\n        if (plugins[i].isMarkerCode) {\r\n            hasIsMarkerCode = true\r\n            break\r\n        }\r\n    }\r\n    \r\n    if (!hasIsMarkerCode) {\r\n        // Add the reset code directly\r\n        return [...codes, resetCode]\r\n    }\r\n    \r\n    // Filter out mode markers by asking each plugin\r\n    const codesWithoutModes: AnsiCodes[] = []\r\n    for (let i = 0; i < codes.length; i++) {\r\n        const code = codes[i]\r\n        let isMarker = false\r\n        // Ask each plugin if this is a marker code\r\n        for (let j = 0; j < plugins.length; j++) {\r\n            const plugin = plugins[j]\r\n            if (plugin.isMarkerCode && plugin.isMarkerCode(code)) {\r\n                isMarker = true\r\n                break\r\n            }\r\n        }\r\n        if (!isMarker) {\r\n            codesWithoutModes.push(code)\r\n        }\r\n    }\r\n    // Add the reset code\r\n    return [...codesWithoutModes, resetCode]\r\n}\r\n\r\n// Modifier ANSI codes - defined at module level\r\nconst modifierCodes = {\r\n    // Modifiers\r\n    reset: { open: '\\x1b[0m', close: '\\x1b[0m' },\r\n    bold: { open: '\\x1b[1m', close: '\\x1b[22m' },\r\n    dim: { open: '\\x1b[2m', close: '\\x1b[22m' },\r\n    italic: { open: '\\x1b[3m', close: '\\x1b[23m' },\r\n    underline: { open: '\\x1b[4m', close: '\\x1b[24m' },\r\n    inverse: { open: '\\x1b[7m', close: '\\x1b[27m' },\r\n    hidden: { open: '\\x1b[8m', close: '\\x1b[28m' },\r\n    strikethrough: { open: '\\x1b[9m', close: '\\x1b[29m' },\r\n}\r\n\r\n// Register modifier codes when module is imported\r\nregisterCodes(modifierCodes)\r\n\r\nexport const modifiersPlugin: StylePlugin = {\r\n    name: 'modifiers',\r\n\r\n    /**\r\n     * Handle property access for modifier functionality and shorthand aliases\r\n     */\r\n    handleProperty(_target: StyledFunction, prop: string, codes: AnsiCodes[], accumulatedText: string, options?: { createStyler?: Function, ansiCodes?: Record<string, AnsiCodes>, pluginRegistry?: any }): StyledFunction | undefined {\r\n        // Handle shorthand aliases\r\n        if (prop === 'r' || prop === 'b' || prop === 'i' || prop === 'u' || prop === 's' || prop === 'd') {\r\n            // Use the passed createStyler function to avoid circular dependencies\r\n            if (options?.createStyler) {\r\n                if (prop === 'r') {\r\n                    // Handle reset\r\n                    const resetCodes = handleReset(codes, modifierCodes.reset)\r\n                    return (options.createStyler as Function)(resetCodes, accumulatedText)\r\n                }\r\n                if (prop === 'b' && modifierCodes.bold) {\r\n                    return (options.createStyler as Function)([...codes, modifierCodes.bold], accumulatedText)\r\n                }\r\n                if (prop === 'i' && modifierCodes.italic) {\r\n                    return (options.createStyler as Function)([...codes, modifierCodes.italic], accumulatedText)\r\n                }\r\n                if (prop === 'u' && modifierCodes.underline) {\r\n                    return (options.createStyler as Function)([...codes, modifierCodes.underline], accumulatedText)\r\n                }\r\n                if (prop === 's' && modifierCodes.strikethrough) {\r\n                    return (options.createStyler as Function)([...codes, modifierCodes.strikethrough], accumulatedText)\r\n                }\r\n                if (prop === 'd' && modifierCodes.dim) {\r\n                    return (options.createStyler as Function)([...codes, modifierCodes.dim], accumulatedText)\r\n                }\r\n            }\r\n        }\r\n\r\n        // Modifiers are handled through the registered codes\r\n        return undefined\r\n    }\r\n}\r\n\r\n// Self-register the plugin when imported\r\nregister(modifiersPlugin)\r\n\r\n// Augment the StyledFunction interface with modifier properties\r\n// This provides IntelliSense for the modifiers\r\ndeclare module '../types' {\r\n    interface StyledFunction {\r\n        // Modifiers\r\n        reset: StyledFunction\r\n        bold: StyledFunction\r\n        dim: StyledFunction\r\n        italic: StyledFunction\r\n        underline: StyledFunction\r\n        inverse: StyledFunction\r\n        hidden: StyledFunction\r\n        strikethrough: StyledFunction\r\n\r\n        // Shorthand aliases for modifiers\r\n        r: StyledFunction  // reset\r\n        b: StyledFunction  // bold\r\n        i: StyledFunction  // italic\r\n        u: StyledFunction  // underline\r\n        s: StyledFunction  // strikethrough\r\n        d: StyledFunction  // dim\r\n    }\r\n}"],"names":["plugins","registerCodes","register"],"mappings":";;;AAUA,SAAS,YAAY,OAAoB,WAAmC;AAExE,MAAI,kBAAkB;AACtB,WAAS,IAAI,GAAG,IAAIA,SAAAA,QAAQ,QAAQ,KAAK;AACrC,QAAIA,SAAAA,QAAQ,CAAC,EAAE,cAAc;AACzB,wBAAkB;AAClB;AAAA,IACJ;AAAA,EACJ;AAEA,MAAI,CAAC,iBAAiB;AAElB,WAAO,CAAC,GAAG,OAAO,SAAS;AAAA,EAC/B;AAGA,QAAM,oBAAiC,CAAA;AACvC,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,UAAM,OAAO,MAAM,CAAC;AACpB,QAAI,WAAW;AAEf,aAAS,IAAI,GAAG,IAAIA,SAAAA,QAAQ,QAAQ,KAAK;AACrC,YAAM,SAASA,SAAAA,QAAQ,CAAC;AACxB,UAAI,OAAO,gBAAgB,OAAO,aAAa,IAAI,GAAG;AAClD,mBAAW;AACX;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,CAAC,UAAU;AACX,wBAAkB,KAAK,IAAI;AAAA,IAC/B;AAAA,EACJ;AAEA,SAAO,CAAC,GAAG,mBAAmB,SAAS;AAC3C;AAGA,MAAM,gBAAgB;AAAA;AAAA,EAElB,OAAO,EAAE,MAAM,WAAW,OAAO,UAAA;AAAA,EACjC,MAAM,EAAE,MAAM,WAAW,OAAO,WAAA;AAAA,EAChC,KAAK,EAAE,MAAM,WAAW,OAAO,WAAA;AAAA,EAC/B,QAAQ,EAAE,MAAM,WAAW,OAAO,WAAA;AAAA,EAClC,WAAW,EAAE,MAAM,WAAW,OAAO,WAAA;AAAA,EACrC,SAAS,EAAE,MAAM,WAAW,OAAO,WAAA;AAAA,EACnC,QAAQ,EAAE,MAAM,WAAW,OAAO,WAAA;AAAA,EAClC,eAAe,EAAE,MAAM,WAAW,OAAO,WAAA;AAC7C;AAGAC,SAAAA,cAAc,aAAa;AAEpB,MAAM,kBAA+B;AAAA,EACxC,MAAM;AAAA;AAAA;AAAA;AAAA,EAKN,eAAe,SAAyB,MAAc,OAAoB,iBAAyB,SAAgI;AAE/N,QAAI,SAAS,OAAO,SAAS,OAAO,SAAS,OAAO,SAAS,OAAO,SAAS,OAAO,SAAS,KAAK;AAE9F,UAAI,mCAAS,cAAc;AACvB,YAAI,SAAS,KAAK;AAEd,gBAAM,aAAa,YAAY,OAAO,cAAc,KAAK;AACzD,iBAAQ,QAAQ,aAA0B,YAAY,eAAe;AAAA,QACzE;AACA,YAAI,SAAS,OAAO,cAAc,MAAM;AACpC,iBAAQ,QAAQ,aAA0B,CAAC,GAAG,OAAO,cAAc,IAAI,GAAG,eAAe;AAAA,QAC7F;AACA,YAAI,SAAS,OAAO,cAAc,QAAQ;AACtC,iBAAQ,QAAQ,aAA0B,CAAC,GAAG,OAAO,cAAc,MAAM,GAAG,eAAe;AAAA,QAC/F;AACA,YAAI,SAAS,OAAO,cAAc,WAAW;AACzC,iBAAQ,QAAQ,aAA0B,CAAC,GAAG,OAAO,cAAc,SAAS,GAAG,eAAe;AAAA,QAClG;AACA,YAAI,SAAS,OAAO,cAAc,eAAe;AAC7C,iBAAQ,QAAQ,aAA0B,CAAC,GAAG,OAAO,cAAc,aAAa,GAAG,eAAe;AAAA,QACtG;AACA,YAAI,SAAS,OAAO,cAAc,KAAK;AACnC,iBAAQ,QAAQ,aAA0B,CAAC,GAAG,OAAO,cAAc,GAAG,GAAG,eAAe;AAAA,QAC5F;AAAA,MACJ;AAAA,IACJ;AAGA,WAAO;AAAA,EACX;AACJ;AAGAC,SAAAA,SAAS,eAAe;;"}